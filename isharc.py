"""
contact:    wlee9829@gmail.com
date:       2024_04_08
python:     python3.10
script:     iSHARC.py

This script assesses the overlap between duplex groups (DGs) generated by
CRSSANT and uses it to filter the iSHARC dataset for further analysis.
"""
# Define version
__version__="1.1.0"

# Version notes
__update_notes__="""
1.2.0
    -   Separated options for subtraction or fraction-based coverage updating.
        See optional flag [-s], defaults to fraction.

1.1.0
    -   Function to determine overlap regions in bedpe, remove coverage from 
        the iSHARC bam based on DG arms.

1.0.0
    -   Initial functions written for parsing input files.
"""

# Import packages
from datetime import datetime
import argparse
import os
import pysam
import subprocess
import sys
import textwrap
import time

###########################################################################
# 1. Define common functions.
def timenow():
    """
    Current timestamp as a string.

    Returns:
        str: Current timestamp in format 'YYY-MM-DD HH:MM:SS'.
    """
    time = str(datetime.now())[:-7]

    return time

def collapse_gene_regions(annotation_file):
    """
    Defines gene region containing by parsing through a modified GTF
    annotation file. This function was written with the hg38 
    annotation in mind. See help section from the bamget.py script for
    details on preparing the modified annotation from a Gencode GTF file.

    Args:
        annotation_file: input annotation file with gene information.

    Returns:
        gene_regions (dict): gene names as keys, chromosome, start, stop
        information as values.
    """

    # Define the valid chromosome names: chr(1-23, X, Y, M)
    valid_chromosomes = set([f"chr{i}" for i in range(1, 23)] + 
        ["chrX", "chrY", "chrM"] + [])
    gene_regions = {}
    with open(annotation_file, 'r') as f:
        for line in f:
            parts = line.split("\t")
            chromosome = parts[0].strip("'\"")
            if chromosome not in valid_chromosomes:
                chromosome = chromosome[3:]
            start = int(parts[1])
            stop = int(parts[2])
            strand = parts[3]
            gene_name = parts[4]

            if gene_name not in gene_regions:
                gene_regions[gene_name] = (chromosome, start, stop)
            else:
                gene_regions[gene_name] = (chromosome,
                    min(start, gene_regions[gene_name][1]), 
                    max(stop, gene_regions[gene_name][2]))

        # # Write the gene regions to BED file.
        # with open("annotation.bed", 'w') as file:
        #     for gene_name, gene_info in gene_regions.items():
        #             chromosome, start, stop = gene_info
        #             file.write(
        #                 f"{chromosome}\t{start}\t{stop}\t{gene_name}\n")

    return gene_regions

def parse_isharc(input_file, gene_regions):
    """
    Reads the iSHARC data into a dictionary, filtering for coverage within
    the specific gene regions. 

    Args: 
        iSHARC bam: input sorted primary bam file after iSHARC mapping
        gene_regions: {gene: [chromosome, start, stop]}

    Returns:
        gene_coverage_dict: {gene:[position, coverage]}
    """
    try:
        if input_file.endswith(".sam"):
            bamfile = f"{input_prefix}.bam"
            subprocess.run(['samtools', 'view', '-bS', '-o', 
                sam_to_bam, input_file], check=True)
        else:
            bamfile = input_file

        subprocess.run(['samtools', 'index', bamfile], check=True)

    except Exception as e:
        error_message = (f"\nERROR: Failed to parse the provided file input."
            f" Check to see if file format is correct. Details: {e}.")
        print(error_message)
        sys.exit()       

    bam = pysam.AlignmentFile(bamfile, "rb")
    total_reads = sum(1 for _ in bam.fetch())

    def generate_coverage():
        processed_reads = 0 # Inititalize counter for processed reads
        gene_coverages = {gene: {} for gene in gene_regions.keys()}

        for read in bam.fetch():
            start = read.reference_start
            end = read.reference_end
            chrom = bam.get_reference_name(read.reference_id)
            
            # Extract read information ONLY if it overlaps gene regions.
            for gene, (gene_chrom, gene_start, gene_end) in \
                gene_regions.items():
                if chrom == gene_chrom \
                    and end >= gene_start \
                    and start <= gene_end:
                    for pos in range(max(start, gene_start), 
                        min(end, gene_end) + 1):
                        gene_coverages[gene][pos] = \
                            gene_coverages[gene].get( pos, 0) + 1

            processed_reads += 1
            # Print progress update at every 10% interval
            if total_reads > 0 and processed_reads % (total_reads // 10) == 0:
                percent_progress = (processed_reads / total_reads) * 100
                print(f"{percent_progress:.2f}% processed:"
                    f" {processed_reads} of {total_reads}")

        return gene_coverages

    gene_coverage_dict = generate_coverage()
    bam.close()

    gene_coverage_dict =  {gene: coverage for gene, 
        coverage in gene_coverage_dict.items() if coverage}
    
    return gene_coverage_dict

def parse_bedpe(bedpe_file):
    """
    Reads the bedpe file to determine the DG number, start/stop locations, 
    and coverage and writes into a dictionary

    Args: 
        bedpe_file: input bedpe file after CRSSANT assembly

    Returns:
        bedpe_dict: 
            {DG:[L_start, L_end, R_start, R_end, coverage]}
    """
    bedpe_dict = {}
    with open(bedpe_file, 'r') as f:
        for line in f:
            fields = line.strip().split('\t')
            names = [name.strip() for name in fields[6].split(',')]
            key = '_'.join(names[:3])
            left_start = int(fields[1]) # Start position of the left arm
            left_end = int(fields[2]) # End position of the left arm
            right_start = int(fields[4]) # Start position of the right arm
            right_end = int(fields[5]) # End position of the right arm
            coverage = int(fields[7]) # Number of DGs at these arm locations
            value = (left_start, left_end, right_start, right_end, coverage)
            bedpe_dict[key] = value

    return bedpe_dict

def coverage_isolation(gene_coverage_dict, bedpe_dict, 
    subtraction_method=None):
    """
    Score the DG positions. If a single arm (either left or right) overlaps 
    that position, add the "coverage" score based on the DG. In instances 
    where the one of the arms overlap, but other arms do not, subtract the 
    score by the "coverage" of each arm. Provide the scoring for the 
    positions.

    Args: 
        bedpe_dict: {DG:[L_start, L_end, R_start, R_end, coverage]}
        gene_coverage_dict: {gene:[position, coverage]}

    Returns:
        gene_scores: {gene:[position, score]}
    """
    if subtraction_method:
        # Subtraction based approach
        for DG, positions in bedpe_dict.items():
            l_start, l_end, r_start, r_end, coverage = positions
            for gene in gene_coverage_dict:
                for pos in range(l_start, l_end + 1):
                    if pos in gene_coverage_dict[gene]:
                        gene_coverage_dict[gene][pos] -= coverage
                for pos in range(r_start, r_end + 1):
                    if pos in gene_coverage_dict[gene]:
                        gene_coverage_dict[gene][pos] -= coverage

    # Coverage fraction based approach
    total_coverage = sum(bedpe_dict[DG][4] for DG in bedpe_dict.values())
    for DG, positions in bedpe_dict.items():
        l_start, l_end, r_start, r_end, coverage = positions
        for gene in gene_coverage_dict:
            for pos in range(l_start, l_end + 1):
                if pos in gene_coverage_dict[gene]:
                    gene_coverage_dict[gene][pos] -= coverage / total_coverage
            for pos in range(r_start, r_end + 1):
                if pos in gene_coverage_dict[gene]:
                    gene_coverage_dict[gene][pos] -= coverage / total_coverage

    isolated_cov =  {gene: coverage for gene, 
        coverage in gene_coverage_dict.items() if coverage}
    
    return isolated_cov

def cov_to_bed(isolated_cov):
    """
    Args: 
        isolated_cov: {gene:[position, coverage]}

    Returns:
        bedgraph: [gene, start, stop, coverage]
    """
    bedgraph = []
    for gene, positions in isolated_reads.items():
        for position, coverage in positions.items():
            start = position - 1
            stop = position
            bedgraph.append([gene, start, stop, coverage])
    with open('updated_coverage.bedgraph', 'w') as f:
        for row in bedgraph:
            f.write('\t'.join(map(str, row)) + '\n')

###########################################################################
# 2. Main, define accepted arguments. 

def parse_args():
    """
    Parse the command-line arguments.
    """
    parser = argparse.ArgumentParser(
        prog="iSHARC.py",
        formatter_class=argparse.RawTextHelpFormatter,
        description=textwrap.dedent("""\
###########################################################################

A script to re-evaluate iSHARC coverage based on the overlaps defined in DG
arms produced by CRSSANT analysis. Output is written to a .bedgraph file can
can be directly visualized in IGV.

NOTE: Arguments must be provided in the following order:

1. annotation:      Annotation file (path) containing gene regions in
                    modified GTF format:

                    chrom   chrom_start   chrom_end   gene_name   strand

                    The modified GTF can be generated using a gencode 
                    annotation file and the following commands:

                    zcat gencode.v45.basic.annotation.gtf.gz
                    awk -F'\\t '$3 == "gene" && $9 ~ /gene_type 
                    "protein_coding"/ && $9 !~ /gene_name "ENSG0000"/ 
                    {split($9, a, "\\""); print $1 "\\t" $4 "\\t" $5 "\\
                    t" a[6] "\\t" $7}' > annotation.bed

                    If providing a pre-made annotation file, the format 
                    must follow the tab-separated columns described above.

                    NOTE: Specific genomic regions or RNAs are masked and 
                    added back as a separate 'chromosome' in the PARIS
                    SHARC pipelines. These must manually be added as
                    separate lines to the annotation_file. Always check 
                    to see if the chromosomes are in the output BED6 files
                    generated using this script.

                    List of genes to be added as a separate 'chromosome':
                    ---------------------------------
                    RN7SK   1       331     RN7SK   +
                    RN7SL   1       288     RN7SL   +
                    RNU7    1       63      RNU7    +
                    RNY     1       112     RNY1    +
                    RNY     213     314     RNY2    +
                    RNY     415     510     RNY3    +
                    RNY     611     694     RNY4    +
                    U13     1       120     U13     +
                    U14AB   1       92      U14A    +
                    U14AB   193     283     U14B    +
                    U17     1       207     U17     +
                    U3      1       217     U3      +
                    U8      1       136     U8      +
                    hs12S   1       954     12S     +
                    hs16S   1       1559    16S     +
                    hs45S   3654    5523    18S     +
                    hs45S   6600    6757    5.8S    +
                    hs45S   7924    12994   28S     +
                    hs5S    1       121     hs5S    +
                    hssnRNA 1       164     U1      +
                    hssnRNA 265     451     U2      +
                    hssnRNA 552     696     U4      +
                    hssnRNA 797     902     U6      +
                    hssnRNA 1003    1118    U5      +
                    hssnRNA 1219    1353    U11     +
                    hssnRNA 1454    1603    U12     +
                    hssnRNA 1704    1833    U4atac  +
                    hssnRNA 1934    2058    U6atac  +
                    ---------------------------------

2. isharc_file:     Intended as PATH of the pri_sorted.bam file generated 
                    after the mapping.sh script from the rna2d3d pipeline is
                    used. However, any SAM or BAM file can be provided for 
                    determining read coverage.

3. bedpe_file:      The PATH of the *.bedpe file generated after CRSSANT 
                    analysis (DG assembly) is complete.

OPTIONAL ARGUMENTS:

-s, --subtraction:  Defines the coverage updating method. Uses subtraction
                    based method instead of the fraction updating. This is
                    only recommended for iSHARC data with high coverage and
                    bedpe that are sparsely populated.

###########################################################################
            """),
    usage=
"""\
\npython3 %(prog)s
""")
    parser.add_argument('annotation', 
        help='PATH to annotation bed file.')
    parser.add_argument('isharc_file', 
        help='PATH to iSHARC data file, provided in BAM format.')
    parser.add_argument('bedpe_file', 
        help='PATH to the .bedpe file generated by CRSSANT analysis')
    parser.add_argument('s', '--subtraction', action='store_true',
        help='Optional parameter to use the subtraction based method.')
    return parser.parse_args()

def main():
    print(timenow(), " Starting analysis of DG file.")

    # Check for input files.
    annotation = args.annotation
    isharc_bam = args.isharc_file
    bedpe = args.bedpe_file

    # Check for optional argument
    subtraction_method = args.subtraction

    print(timenow() + f" Collecting gene regions from {annotation}...")
    gene_regions = collapse_gene_regions(annotation)
    
    print(timenow() + f" Filtering coverage based on gene regions...")
    gene_coverage_dict = parse_isharc(isharc_bam, gene_regions)
    
    print(timenow() + f" Updating coverage scores based on DG overlaps...")
    bedpe_dict = parse_bedpe(bedpe)
    new_coverage = coverage_isolation(gene_coverage_dict, bedpe_dict,
        subtraction_method)
    cov_to_bed(new_coverage)

    print(timenow() + f" Job completed.")

if __name__ == "__main__":
    args = parse_args()
    main()
    sys.exit()