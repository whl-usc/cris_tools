"""
contact:    wlee9829@gmail.com
date:       2024_04_08
python:     python3.10
script:     iSHARC.py

This script assesses the overlap between duplex groups (DGs) generated by
CRSSANT and uses it to filter the iSHARC dataset for further analysis.
"""
# Define version
__version__="1.0.0"

# Version notes
__update_notes__="""
1.0.0
    -   Initial function to parse the input files.
"""

# Import packages
from datetime import datetime
import argparse
import os
import pysam
import subprocess
import sys
import textwrap
import time

###########################################################################
# 1. Define common functions.
def timenow():
    """
    Current timestamp as a string.

    Returns:
        str: Current timestamp in format 'YYY-MM-DD HH:MM:SS'.
    """
    time = str(datetime.now())[:-7]

    return time

def collapse_gene_regions(annotation_file):
    """
    Defines gene region containing by parsing through a modified GTF
    annotation file. This function was written with the hg38 
    annotation in mind. See help section from the bamget.py script for
    details on preparing the modified annotation from a Gencode GTF file.

    Args:
        annotation_file: input annotation file with gene information.

    Returns:
        gene_regions (dict): gene names as keys, chromosome, start, stop
        information as values.        
    """

    # Define the valid chromosome names: chr(1-23, X, Y, M)
    valid_chromosomes = set([f"chr{i}" for i in range(1, 23)] + 
        ["chrX", "chrY", "chrM"] + [])
    gene_regions = {}
    with open(annotation_file, 'r') as f:
        for line in f:
            parts = line.split("\t")
            chromosome = parts[0].strip("'\"")
            if chromosome not in valid_chromosomes:
                chromosome = chromosome[3:]
            start = int(parts[1])
            stop = int(parts[2])
            strand = parts[3]
            gene_name = parts[4]

            if gene_name not in gene_regions:
                gene_regions[gene_name] = (chromosome, start, stop)
            else:
                gene_regions[gene_name] = (chromosome,
                    min(start, gene_regions[gene_name][1]), 
                    max(stop, gene_regions[gene_name][2]))

        # # Write the gene regions to BED file.
        # with open("annotation.bed", 'w') as file:
        #     for gene_name, gene_info in gene_regions.items():
        #             chromosome, start, stop = gene_info
        #             file.write(
        #                 f"{chromosome}\t{start}\t{stop}\t{gene_name}\n")

    return gene_regions

def parse_isharc(bam_file, gene_regions):
    """
    Reads the iSHARC data into a dictionary, filtering for coverage within
    the specific gene regions. 
    """
    bam = pysam.AlignmentFile(bam_file, "rb")
    total_reads = sum(1 for _ in bam.fetch())

    def generate_coverage():
        processed_reads = 0 # Inititalize counter for processed reads
        gene_coverages = {gene: {} for gene in gene_regions.keys()}

        for read in bam.fetch():
            start = read.reference_start
            end = read.reference_end
            chrom = bam.get_reference_name(read.reference_id)
            
            # Extract read information ONLY if it overlaps gene regions.
            for gene, (gene_chrom, gene_start, gene_end) in \
                gene_regions.items():
                if chrom == gene_chrom \
                    and end >= gene_start \
                    and start <= gene_end:
                    for pos in range(max(start, gene_start), 
                        min(end, gene_end) + 1):
                        gene_coverages[gene][pos] = \
                            gene_coverages[gene].get( pos, 0) + 1

            processed_reads += 1
            # Print progress update at every 10% interval
            if total_reads > 0 and processed_reads % (total_reads // 10) == 0:
                percent_progress = (processed_reads / total_reads) * 100
                print(f"{percent_progress:.2f}% processed:"
                    f" {processed_reads} of {total_reads}")

        return gene_coverages

    gene_coverage_dict = generate_coverage()
    bam.close()

    return gene_coverage_dict

def parse_bedpe(bedpe_file):
    bedpe_dict = {}
    with open(bedpe_file, 'r') as f:
        for line in f:
            fields = line.strip().split('\t')
            names = [name.strip() for name in fields[6].split(',')]
            key = '_'.join(names[:3])
            left_start = int(fields[1]) # Start position of the left arm
            left_end = int(fields[2]) # End position of the left arm
            right_start = int(fields[4]) # Start position of the right arm
            right_end = int(fields[5]) # End position of the right arm
            coverage = int(fields[7]) # Number of DGs at these arm locations
            value = (left_start, left_end, right_start, right_end, coverage)
            bedpe_dict[key] = value

    return bedpe_dict

###########################################################################
# 2. Main, define accepted arguments. 

def parse_args():
    """
    Parse the command-line arguments.
    """
    parser = argparse.ArgumentParser(
        prog="iSHARC.py",
        formatter_class=argparse.RawTextHelpFormatter,
        description=textwrap.dedent("""\
###########################################################################

Add description and help text here.

###########################################################################
            """),
    usage=
"""\
\npython3 %(prog)s
""")
    parser.add_argument('annotation', 
        help='PATH to annotation bed file.')
    parser.add_argument('isharc_file', 
        help='PATH to iSHARC data file, provided in BAM format.')
    parser.add_argument('bedpe_file', 
        help='PATH to the bedpe file generated by CRSSANT analysis')

    return parser.parse_args()

def main():
    # print(timenow(), "Starting analysis of DG file.")
    start_time = time.time()

    # Check for input files.
    annotation = args.annotation
    isharc_bam = args.isharc_file
    bedpe = args.bedpe_file

    print(f"Collecting gene regions from {annotation}...")
    gene_regions = collapse_gene_regions(annotation)
    print(f"Filtering coverage based on gene regions...")
    parse_isharc(isharc_bam, gene_regions)
    parse_bedpe(bedpe)

if __name__ == "__main__":
    args = parse_args()
    main()