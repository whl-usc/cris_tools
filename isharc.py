"""
contact:    wlee9829@gmail.com
date:       2024_04_08
python:     python3.10
script:     iSHARC.py

This script assesses the overlap between duplex groups (DGs) generated by
CRSSANT and uses it to filter the iSHARC dataset for further analysis.
"""
# Define version
__version__="1.3.0"

# Version notes
__update_notes__="""
1.3.0
    -   Separated options for subtraction of "all" DG or the lowest
        confidence DG for coverage updating. (See optional flag [-s]).
    -   Updated some docstrings to clarify functions.
1.2.0
    -   Changed to BAM input processing with .fetch() to speed up read
        coverage updating. 
1.1.0
    -   Function to determine overlap regions in bedpe, remove coverage from 
        the iSHARC bam based on DG arms.

1.0.0
    -   Initial functions written for parsing input files.
"""

# Import packages
from datetime import datetime
import argparse
import os
import pysam
import subprocess
import sys
import textwrap
import time

###########################################################################
# 1. Define common functions.
def timenow():
    """
    Current timestamp as a string.

    Returns:
        str: Current timestamp in format 'YYY-MM-DD HH:MM:SS'.
    """
    time = str(datetime.now())[:-7]

    return time

def collapse_gene_regions(annotation_file):
    """
    Defines gene region containing by parsing through a modified GTF
    annotation file. This function was written with the hg38 
    annotation in mind. See help section from the bamget.py script for
    details on preparing the modified annotation from a Gencode GTF file.

    Args:
        annotation_file: input annotation file with gene information.

    Returns:
        gene_regions (dict): gene names as keys, chromosome, start, stop
        information as values.
    """
    # Define valid chromosome names: chr(1-23, X, Y, M)
    valid_chromosomes = set([f"chr{i}" for i in range(1, 23)] + 
        ["chrX", "chrY", "chrM"] + [])
    gene_regions = {}
    with open(annotation_file, 'r') as f:
        for line in f:
            parts = line.split("\t")
            chromosome = parts[0].strip("'\"")
            if chromosome not in valid_chromosomes:
                chromosome = chromosome[3:]
            start = int(parts[1])
            stop = int(parts[2])
            strand = parts[3]
            gene_name = parts[4]

            if gene_name not in gene_regions:
                gene_regions[gene_name] = (chromosome, start, stop)
            else:
                gene_regions[gene_name] = (chromosome,
                    min(start, gene_regions[gene_name][1]), 
                    max(stop, gene_regions[gene_name][2]))

    return gene_regions

def parse_isharc(input_file, gene_regions):
    """
    Reads the iSHARC data into a dictionary, filtering for coverage within
    the specific gene regions. 

    Args: 
        iSHARC bam: input sorted primary bam file after iSHARC mapping
        gene_regions: {gene: [chromosome, start, stop]}

    Returns:
        gene_coverage: {gene:{position: coverage}}
    """
    try:
        bamfile = input_file if input_file.endswith(".bam") \
            else f"{input_file[:-4]}.bam"
        
        if not bamfile.endswith(".bam"):
            subprocess.run(['samtools', 'view', '-bS', '-o', bamfile,
                input_file], check=True)

        # Index BAM file
        subprocess.run(['samtools', 'index', bamfile], check=True)

    except Exception as e:
        error_message = (f"\nERROR: Failed to parse the provided file input."
            f" Check to see if file format is correct. Details: {e}.")
        print(error_message)
        sys.exit()       

    bam = pysam.AlignmentFile(bamfile, "rb")
    total_genes = len(gene_regions); interval = total_genes // 10
    processed_genes = 0

    # Process reads and generate coverage
    gene_coverage = {}
    for gene, (gene_chrom, gene_start, gene_end) in gene_regions.items():
        try: gene_reads = bam.fetch(gene_chrom, gene_start, gene_end)
        except: pass
        # Process overlapping reads
        for read in gene_reads:
            start = read.reference_start
            end = read.reference_end
            # Ensure read overlaps with gene region
            if start <= gene_end and end >= gene_start:
                for pos in range(max(start, gene_start), 
                    min(end, gene_end) + 1):
                    gene_coverage.setdefault(gene, {})
                    gene_coverage[gene][pos] = \
                        gene_coverage[gene].get(pos, 0) + 1

        processed_genes += 1
        if processed_genes % interval == 0:
            progress_percent = (processed_genes / total_genes) * 100
            print('.'*20 + f"{progress_percent:.2f}% processed" + '.'*20)

    bam.close()

    print(gene_coverage) # In case of discrepancy, check this dictionary.
    return gene_coverage

def parse_bedpe(bedpe_file):
    """
    Reads the bedpe file to determine the DG number, start/stop locations, 
    and coverage and writes into a dictionary

    Args: 
        bedpe_file: input bedpe file after CRSSANT assembly

    Returns:
        bedpe_dict: 
            {DG:[l_chr, l_start, l_end, r_chr, r_start, r_end, coverage]}
    """
    bedpe_dict = {}
    with open(bedpe_file, 'r') as f:
        for line in f:
            fields = line.strip().split('\t')
            names = [name.strip() for name in fields[6].split(',')]
            key = '_'.join(names[:3])
            l_chr = str(fields[0]) # Chromosome of left arm
            l_start = int(fields[1]) # Start position of the left arm
            l_end = int(fields[2]) # End position of the left arm
            r_chr = str(fields[3]) # Chromosome of right arm
            r_start = int(fields[4]) # Start position of the right arm
            r_end = int(fields[5]) # End position of the right arm
            coverage = int(fields[7]) # Number of DGs at these arm locations
            confidence = float(names[-1]) # Extracting the DG confidence
            value = (l_chr, l_start, l_end,
                r_chr, r_start, r_end,
                coverage, confidence)
            bedpe_dict[key] = value
    
    # print(bedpe_dict) # In case of discrepancy, check this dictionary.
    return bedpe_dict

def coverage_isolation(gene_coverage, bedpe_dict, 
    method):
    """
    Score positions based on DG coverage. 

    For the subtraction-based approach: If a single arm (either left or 
    right) overlaps a given position, subtract DG coveragefrom iSHARC
    coverage. 

    For the low_confidence cleanup approach: If a single arm overlaps a 
    position, keep the coverage value. Only subtract by the lowest confidence 
    DGs whenever there is an overlap of DG arms.

    Args: 
        bedpe_dict: {DG:[l_chr, l_start, l_end, 
                    r_chr, r_start, r_end, coverage]}
        gene_coverage: {gene:{position: coverage}}
        method: subtract OR confidence
    Returns:
        (updated) gene_coverage: {gene:{position: coverage}}
    """
    # Subtraction: Removes coverage based on all DG coverage
    if method == 'subtract':
        for dg_key, dg_data in bedpe_dict.items():
            (l_chr, l_start, l_end, r_chr, r_start, r_end, 
            coverage, _) = dg_data
            for gene in gene_coverage:
                for pos in range(l_start, l_end + 1):
                    if pos in gene_coverage[gene]:
                        gene_coverage[gene][pos] -= coverage
                for pos in range(r_start, r_end + 1):
                    if pos in gene_coverage[gene]:
                        gene_coverage[gene][pos] -= coverage

    # Confidence: subtract lowest conf DG coverage from gene_coverage.
    elif method == 'confidence':
        conf_pos = {}; low_conf_per_pos = {}  
        for dg_key, dg_data in bedpe_dict.items():
            (l_chr, l_start, l_end, r_chr, r_start, r_end, 
            coverage, confidence) = dg_data

            for position in range(l_start, r_end + 1):
                conf_pos.setdefault(position, []).append(confidence)
                if position not in low_conf_per_pos:
                    low_conf_per_pos[position] = \
                        (dg_key, coverage, confidence)
                else:
                    _, _, existing_confidence = \
                        low_conf_per_pos[position]
                    if confidence < existing_confidence:
                        low_conf_per_pos[position] = \
                        (dg_key, coverage, confidence)

        # Iterate through position with multiple confidence values
        num_low_conf_reads = 2
        for position, dg_info_list in conf_pos.items():
            if len(dg_info_list) > 1:
                # Sort low_conf_per_pos by conf, get lowest conf
                lowset_conf_reads = sorted(dg_info_list, key=lambda x: x[2])[:num_low_conf_reads]
                print("Lowest confidence reads:", lowest_conf_reads)
                for dg_key, coverage, _ in lowest_conf_reads:
                    # Subtract coverage from the gene in gene_coverage
                    for gene, positions in gene_coverage.items():
                        if position in positions:
                            gene_coverage[gene][position] -= coverage
                            break

    else:
        print(f"Method must either be 'subtract' or 'confidence'.")
        sys.exit()



    print(gene_coverage)
    return(gene_coverage)

def cov_to_bed(gene_coverage):
    """
    Args: 
        gene_coverage: {gene:{position, coverage}}

    Returns:
        bedgraph: [gene, start, stop, coverage]
    """
    bedgraph = [[gene, pos - 1, pos, coverage]
        for gene, positions in gene_coverage.items()
        for pos, coverage in positions.items()]

    with open('updated_coverage.bedgraph', 'w') as f:
        for row in bedgraph:
            f.write('\t'.join(map(str, row)) + '\n')

###########################################################################
# 2. Main, define accepted arguments. 

def parse_args():
    """
    Parse the command-line arguments.
    """
    parser = argparse.ArgumentParser(
        prog="iSHARC.py",
        formatter_class=argparse.RawTextHelpFormatter,
        description=textwrap.dedent("""\
###########################################################################

A script to re-evaluate iSHARC coverage based on the overlaps defined in DG
arms produced by CRSSANT analysis. Output is written to a .bedgraph file can
can be directly visualized in IGV.

NOTE: Arguments must be provided in the following order:

1. annotation:      Annotation file (path) containing gene regions in
                    modified GTF format:

                    chrom   chrom_start   chrom_end   gene_name   strand

                    The modified GTF can be generated using a gencode 
                    annotation file and the following commands:

                    zcat gencode.v45.basic.annotation.gtf.gz
                    awk -F'\\t '$3 == "gene" && $9 ~ /gene_type 
                    "protein_coding"/ && $9 !~ /gene_name "ENSG0000"/ 
                    {split($9, a, "\\""); print $1 "\\t" $4 "\\t" $5 "\\
                    t" a[6] "\\t" $7}' > annotation.bed

                    If providing a pre-made annotation file, the format 
                    must follow the tab-separated columns described above.

                    NOTE: Specific genomic regions or RNAs are masked and 
                    added back as a separate 'chromosome' in the PARIS
                    SHARC pipelines. These must manually be added as
                    separate lines to the annotation_file. Always check 
                    to see if the chromosomes are in the output BED6 files
                    generated using this script.

                    List of genes to be added as a separate 'chromosome':
                    ---------------------------------
                    RN7SK   1       331     RN7SK   +
                    RN7SL   1       288     RN7SL   +
                    RNU7    1       63      RNU7    +
                    RNY     1       112     RNY1    +
                    RNY     213     314     RNY2    +
                    RNY     415     510     RNY3    +
                    RNY     611     694     RNY4    +
                    U13     1       120     U13     +
                    U14AB   1       92      U14A    +
                    U14AB   193     283     U14B    +
                    U17     1       207     U17     +
                    U3      1       217     U3      +
                    U8      1       136     U8      +
                    hs12S   1       954     12S     +
                    hs16S   1       1559    16S     +
                    hs45S   3654    5523    18S     +
                    hs45S   6600    6757    5.8S    +
                    hs45S   7924    12994   28S     +
                    hs5S    1       121     hs5S    +
                    hssnRNA 1       164     U1      +
                    hssnRNA 265     451     U2      +
                    hssnRNA 552     696     U4      +
                    hssnRNA 797     902     U6      +
                    hssnRNA 1003    1118    U5      +
                    hssnRNA 1219    1353    U11     +
                    hssnRNA 1454    1603    U12     +
                    hssnRNA 1704    1833    U4atac  +
                    hssnRNA 1934    2058    U6atac  +
                    ---------------------------------

2. isharc_file:     Intended as PATH of the pri_sorted.bam file generated 
                    after the mapping.sh script from the rna2d3d pipeline is
                    used. However, any SAM or BAM file can be provided for 
                    determining read coverage.

3. bedpe_file:      The PATH of the *.bedpe file generated after CRSSANT 
                    analysis (DG assembly) is complete.

4. method:          "confidence" or "subtraction"

                    Defines the coverage scoring method. Use total subtraction
                    based method instead of partial updating based on lowest 
                    DG coverage. For reads with overlapping positions, iSHARC 
                    read coverage is subtracted by the total number of DG 
                    coverage. This is only recommended for iSHARC reads at 
                    high coverage and sparsely populated DG data.

OPTIONAL ARGUMENTS:

--dgs, --min_dg:    the number of low confidence DGs to remove the coverage by. 

###########################################################################
            """),
    usage=
"""\
\npython3 %(prog)s annotation iSHARC CRSSANT method
""")
    parser.add_argument('annotation', 
        help='PATH to annotation bed file.')
    parser.add_argument('isharc_file', 
        help='PATH to iSHARC data file, provided in BAM format.')
    parser.add_argument('bedpe_file', 
        help='PATH to the .bedpe file generated by CRSSANT analysis')
    parser.add_argument('method',
        help='Either "confidence" or "subtract" to clean up coverage.')
    return parser.parse_args()

def main():
    print(timenow(), "Starting analysis of DG file.")

    # Check for input files.
    annotation = args.annotation
    isharc_bam = args.isharc_file
    bedpe = args.bedpe_file
    # Check for optional argument
    method = args.method

    # Start collecting gene regions based on annotation file.
    print(timenow(), f"Collecting gene regions from {annotation}...")
    gene_regions = collapse_gene_regions(annotation)
    # Start sorting reads based on gene regions.
    print(timenow(), f"Filtering coverage based on gene regions...\n")
    gene_coverage_dict = parse_isharc(isharc_bam, gene_regions)
    # Re-score coverage subracting by all or partial.
    print("\n" + timenow(), 
        f"Updating coverage scores based on DG overlaps...\n")
    bedpe_dict = parse_bedpe(bedpe)
    new_coverage = coverage_isolation(gene_coverage_dict, bedpe_dict,
        method)
    cov_to_bed(new_coverage)

    print("\n" + timenow(), f"Job completed...\n")

if __name__ == "__main__":
    args = parse_args()
    main()
    sys.exit()